class MedianFinder {
  constructor() {
    // Max heap for lower half (stores negative values for max behavior)
    this.maxHeap = [];
    // Min heap for upper half
    this.minHeap = [];
  }

  /**
   * @param {number} num
   * @return {void}
   */
  // ...existing code...
  addNum(num) {
    // Add to max heap (lower half)
    if (this.maxHeap.length === 0 || num <= -this.maxHeap[0]) {
      this.maxHeap.push(-num);
      this._bubbleUp(this.maxHeap, this.maxHeap.length - 1);
    } else {
      this.minHeap.push(num);
      this._bubbleUp(this.minHeap, this.minHeap.length - 1);
    }

    // Balance heaps - _removeTop already maintains heap property
    if (this.maxHeap.length > this.minHeap.length + 1) {
      const val = -this._removeTop(this.maxHeap);
      this.minHeap.push(val);
      this._bubbleUp(this.minHeap, this.minHeap.length - 1);
    } else if (this.minHeap.length > this.maxHeap.length) {
      const val = -this._removeTop(this.minHeap);
      this.maxHeap.push(val);
      this._bubbleUp(this.maxHeap, this.maxHeap.length - 1);
    }
  }
// ...existing code...

  /**
   * @return {number}
   */
  findMedian() {
    if (this.maxHeap.length === this.minHeap.length) {
      return (-this.maxHeap[0] + this.minHeap[0]) / 2;
    }
    return -this.maxHeap[0];
  }

  _bubbleUp(heap, index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      if (heap[index] >= heap[parentIndex]) break;
      [heap[index], heap[parentIndex]] = [heap[parentIndex], heap[index]];
      index = parentIndex;
    }
  }

  _removeTop(heap) {
    const top = heap[0];
    const last = heap.pop();
    if (heap.length > 0) {
      heap[0] = last;
      this._bubbleDown(heap, 0);
    }
    return top;
  }

  _bubbleDown(heap, index) {
    while (true) {
      let smallest = index;
      const left = 2 * index + 1;
      const right = 2 * index + 2;

      if (left < heap.length && heap[left] < heap[smallest]) {
        smallest = left;
      }
      if (right < heap.length && heap[right] < heap[smallest]) {
        smallest = right;
      }
      if (smallest === index) break;

      [heap[index], heap[smallest]] = [heap[smallest], heap[index]];
      index = smallest;
    }
  }
}